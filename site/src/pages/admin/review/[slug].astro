---
export const prerender = false;

import AdminLayout from "../../../layouts/AdminLayout.astro";
import fs from "node:fs";
import path from "node:path";
import { execSync } from "node:child_process";

// Check admin access
if (!import.meta.env.ENABLE_ADMIN) {
  return Astro.redirect("/");
}

const { slug } = Astro.params;
const CACHE_DIR = "/Users/jd/Projects/pda/cache/articles";
const PARSER_SCRIPT = "/Users/jd/Projects/pda/scripts/parse_article_structure.py";
const PYTHON = "/opt/homebrew/bin/python3.11";

const htmlPath = path.join(CACHE_DIR, `${slug}.html`);
const jsonPath = path.join(CACHE_DIR, `${slug}.json`);

// Check if HTML exists
if (!fs.existsSync(htmlPath)) {
  return Astro.redirect("/admin/review");
}

// Run parser if JSON doesn't exist or is older than HTML
let needsParse = !fs.existsSync(jsonPath);
if (!needsParse) {
  const htmlStat = fs.statSync(htmlPath);
  const jsonStat = fs.statSync(jsonPath);
  needsParse = htmlStat.mtimeMs > jsonStat.mtimeMs;
}

if (needsParse) {
  try {
    execSync(`${PYTHON} "${PARSER_SCRIPT}" "${htmlPath}"`, {
      encoding: "utf-8",
      timeout: 30000,
    });
  } catch (e) {
    console.error("Parser failed:", e);
  }
}

// Load parsed data
interface ParsedArticle {
  source_file: string;
  title: string | null;
  article_type: string | null;
  authors: string | null;
  citation: string | null;
  abstract: string | null;
  body_html: string;
  acknowledgements: string | null;
  references: string[];
  figures: Array<{ alt: string; src: string; caption: string | null }>;
  tables: Array<{ caption: string | null; preview: string }>;
  stripped_cruft: string[];
  warnings: string[];
}

let parsed: ParsedArticle | null = null;
let parseError: string | null = null;

try {
  if (fs.existsSync(jsonPath)) {
    const jsonContent = fs.readFileSync(jsonPath, "utf-8");
    parsed = JSON.parse(jsonContent);
  }
} catch (e) {
  parseError = String(e);
}

// Read raw HTML for storage and body display
let rawHtml = "";
let bodyHtml = "";
if (parsed) {
  try {
    rawHtml = fs.readFileSync(htmlPath, "utf-8");
    // Re-run parser in memory to get full body
    const result = execSync(
      `${PYTHON} -c "
import sys
sys.path.insert(0, '/Users/jd/Projects/pda/scripts')
from parse_article_structure import parse_article
from pathlib import Path
result = parse_article(Path('${htmlPath}'))
print(result['body_html'] or '')
"`,
      { encoding: "utf-8", maxBuffer: 50 * 1024 * 1024, timeout: 30000 }
    );
    bodyHtml = result;
  } catch (e) {
    console.error("Could not get body HTML:", e);
  }
}

// Extract year from citation if possible
function extractYear(citation: string | null): string {
  if (!citation) return "";
  const match = citation.match(/\b(19|20)\d{2}\b/);
  return match ? match[0] : "";
}

// Run enhancement script to get suggestions
interface EnhancementSuggestions {
  method?: string;
  voice?: string;
  peer_reviewed?: boolean;
}

let suggestions: EnhancementSuggestions = {};
if (fs.existsSync(jsonPath)) {
  try {
    const result = execSync(
      `${PYTHON} /Users/jd/Projects/pda/scripts/enhance_parsed_article.py "${jsonPath}" --suggest 2>&1`,
      { encoding: "utf-8", timeout: 10000 }
    );
    // Parse output for suggestions
    const methodMatch = result.match(/method:[\s\S]*?Suggested:\s*(\w+)/);
    const voiceMatch = result.match(/voice:[\s\S]*?Suggested:\s*(\w+)/);
    const peerMatch = result.match(/peer_reviewed:[\s\S]*?Suggested:\s*(True|False)/);

    if (methodMatch) suggestions.method = methodMatch[1];
    if (voiceMatch) suggestions.voice = voiceMatch[1];
    if (peerMatch) suggestions.peer_reviewed = peerMatch[1] === 'True';
  } catch (e) {
    console.error("Enhancement script failed:", e);
  }
}

// Count stats
const bodyLength = bodyHtml.length;
const refCount = parsed?.references?.length || 0;
const figCount = parsed?.figures?.length || 0;
const tableCount = parsed?.tables?.length || 0;
const cruftCount = parsed?.stripped_cruft?.length || 0;
const joinCount = parsed?.stripped_cruft?.filter((c) => c.startsWith("[JOINED]")).length || 0;
const warningCount = parsed?.warnings?.length || 0;
const yearFromCitation = extractYear(parsed?.citation || null);
---

<AdminLayout title={`Review: ${slug}`}>
  <div class="space-y-6">
    <!-- Back link -->
    <div>
      <a href="/admin/review" class="text-sm text-primary-500 hover:text-primary-700">
        &larr; Back to list
      </a>
    </div>

    <!-- Page Header -->
    <div class="flex items-start justify-between">
      <div>
        <h1 class="text-2xl font-bold text-stone-900 break-all">{slug}</h1>
        <p class="mt-1 text-sm text-stone-500">
          Review parsed structure before importing
        </p>
      </div>
      <div class="flex gap-2">
        <a
          href={`file://${htmlPath}`}
          target="_blank"
          class="rounded bg-stone-100 px-3 py-2 text-sm font-medium text-stone-600 hover:bg-stone-200"
        >
          View Raw HTML
        </a>
      </div>
    </div>

    {parseError ? (
      <div class="rounded-lg bg-red-50 border border-red-200 p-4">
        <h2 class="text-sm font-medium text-red-800">Parse Error</h2>
        <pre class="mt-2 text-xs text-red-700 overflow-auto">{parseError}</pre>
      </div>
    ) : parsed ? (
      <>
        <!-- Stats Row -->
        <div class="flex flex-wrap gap-3">
          <div class="rounded bg-white px-3 py-2 shadow-sm">
            <span class="text-xs text-stone-500">Body</span>
            <span class="ml-2 font-medium text-stone-900">{Math.round(bodyLength / 1024)} KB</span>
          </div>
          <div class="rounded bg-white px-3 py-2 shadow-sm">
            <span class="text-xs text-stone-500">References</span>
            <span class="ml-2 font-medium text-stone-900">{refCount}</span>
          </div>
          <div class="rounded bg-white px-3 py-2 shadow-sm">
            <span class="text-xs text-stone-500">Figures</span>
            <span class="ml-2 font-medium text-stone-900">{figCount}</span>
          </div>
          <div class="rounded bg-white px-3 py-2 shadow-sm">
            <span class="text-xs text-stone-500">Tables</span>
            <span class="ml-2 font-medium text-stone-900">{tableCount}</span>
          </div>
          <div class="rounded bg-white px-3 py-2 shadow-sm">
            <span class="text-xs text-stone-500">Cruft Stripped</span>
            <span class="ml-2 font-medium text-amber-600">{cruftCount - joinCount}</span>
          </div>
          <div class="rounded bg-white px-3 py-2 shadow-sm">
            <span class="text-xs text-stone-500">Paragraphs Joined</span>
            <span class="ml-2 font-medium text-green-600">{joinCount}</span>
          </div>
          {warningCount > 0 && (
            <div class="rounded bg-red-50 px-3 py-2 shadow-sm border border-red-200">
              <span class="text-xs text-red-600">Warnings</span>
              <span class="ml-2 font-medium text-red-700">{warningCount}</span>
            </div>
          )}
        </div>

        <!-- Warnings Card -->
        {warningCount > 0 && (
          <div class="rounded-lg bg-red-50 border border-red-200 p-6">
            <h2 class="text-lg font-semibold text-red-800 border-b border-red-200 pb-2 mb-4">
              Warnings — Needs Review
              <span class="text-sm font-normal text-red-600 ml-2">
                ({warningCount})
              </span>
            </h2>
            <ul class="space-y-2 text-sm">
              {parsed.warnings.map((item) => (
                <li class="font-mono text-xs p-2 rounded bg-red-100 text-red-800">
                  {item}
                </li>
              ))}
            </ul>
          </div>
        )}

        <!-- Editable Metadata Form -->
        <form id="article-form" class="rounded-lg bg-white shadow-sm p-6 space-y-4">
          <div class="flex items-center justify-between border-b border-stone-200 pb-2">
            <h2 class="text-lg font-semibold text-stone-900">
              Article Metadata
            </h2>
            <div class="flex gap-2">
              <button
                type="button"
                id="reset-btn"
                class="rounded bg-stone-100 px-3 py-1.5 text-sm font-medium text-stone-600 hover:bg-stone-200"
              >
                Reset
              </button>
              <button
                type="submit"
                class="rounded bg-primary-500 px-4 py-1.5 text-sm font-medium text-white hover:bg-primary-600"
              >
                Save to Database
              </button>
            </div>
          </div>

          <div id="form-status" class="hidden rounded p-3 text-sm"></div>

          <div class="grid gap-4">
            <!-- Classification: Method, Voice, Peer Reviewed -->
            <div class="grid grid-cols-3 gap-4 p-4 bg-stone-50 rounded-lg border border-stone-200">
              <div>
                <label for="method" class="block text-xs font-medium text-stone-500 uppercase tracking-wide">
                  Method <span class="text-red-500">*</span>
                </label>
                <select
                  id="method"
                  name="method"
                  required
                  class="mt-1 w-full rounded border border-stone-300 px-3 py-2 text-sm bg-white focus:border-primary-500 focus:ring-1 focus:ring-primary-500"
                >
                  <option value="">Select...</option>
                  <option value="empirical" selected={suggestions.method === 'empirical'}>Empirical — original data</option>
                  <option value="synthesis" selected={suggestions.method === 'synthesis'}>Synthesis — review/meta-analysis</option>
                  <option value="theoretical" selected={suggestions.method === 'theoretical'}>Theoretical — conceptual/critique</option>
                  <option value="lived_experience" selected={suggestions.method === 'lived_experience'}>Lived Experience — personal account</option>
                </select>
                {parsed.article_type && (
                  <p class="mt-1 text-xs text-stone-500">
                    Hint: "{parsed.article_type}"
                  </p>
                )}
              </div>
              <div>
                <label for="voice" class="block text-xs font-medium text-stone-500 uppercase tracking-wide">
                  Voice <span class="text-red-500">*</span>
                </label>
                <select
                  id="voice"
                  name="voice"
                  required
                  class="mt-1 w-full rounded border border-stone-300 px-3 py-2 text-sm bg-white focus:border-primary-500 focus:ring-1 focus:ring-primary-500"
                >
                  <option value="">Select...</option>
                  <option value="academic" selected={suggestions.voice === 'academic'}>Academic — researchers/scholars</option>
                  <option value="practitioner" selected={suggestions.voice === 'practitioner'}>Practitioner — clinicians/educators</option>
                  <option value="organization" selected={suggestions.voice === 'organization'}>Organization — charities/institutions</option>
                  <option value="individual" selected={suggestions.voice === 'individual'}>Individual — personal voice</option>
                </select>
              </div>
              <div>
                <label class="block text-xs font-medium text-stone-500 uppercase tracking-wide mb-1">
                  Peer Reviewed
                </label>
                <label class="inline-flex items-center mt-2">
                  <input
                    type="checkbox"
                    id="peer_reviewed"
                    name="peer_reviewed"
                    checked={suggestions.peer_reviewed}
                    class="rounded border-stone-300 text-primary-500 focus:ring-primary-500"
                  />
                  <span class="ml-2 text-sm text-stone-700">Yes, peer reviewed</span>
                </label>
              </div>
            </div>

            <div>
              <label for="title" class="block text-xs font-medium text-stone-500 uppercase tracking-wide">
                Title <span class="text-red-500">*</span>
              </label>
              <input
                type="text"
                id="title"
                name="title"
                value={parsed.title || ""}
                required
                class="mt-1 w-full rounded border border-stone-300 px-3 py-2 text-sm focus:border-primary-500 focus:ring-1 focus:ring-primary-500"
              />
            </div>

            <div class="grid grid-cols-2 gap-4">
              <div>
                <label for="authors" class="block text-xs font-medium text-stone-500 uppercase tracking-wide">Authors</label>
                <input
                  type="text"
                  id="authors"
                  name="authors"
                  value={parsed.authors || ""}
                  placeholder="e.g., A. Smith, B. Jones"
                  class="mt-1 w-full rounded border border-stone-300 px-3 py-2 text-sm focus:border-primary-500 focus:ring-1 focus:ring-primary-500"
                />
              </div>
              <div>
                <label for="year" class="block text-xs font-medium text-stone-500 uppercase tracking-wide">Year</label>
                <input
                  type="text"
                  id="year"
                  name="year"
                  value={yearFromCitation}
                  placeholder="e.g., 2018"
                  pattern="\d{4}"
                  class="mt-1 w-full rounded border border-stone-300 px-3 py-2 text-sm focus:border-primary-500 focus:ring-1 focus:ring-primary-500"
                />
              </div>
            </div>

            <div>
              <label for="citation" class="block text-xs font-medium text-stone-500 uppercase tracking-wide">Citation</label>
              <input
                type="text"
                id="citation"
                name="citation"
                value={parsed.citation || ""}
                placeholder="e.g., Journal Name 66 (2018) 103-108"
                class="mt-1 w-full rounded border border-stone-300 px-3 py-2 text-sm focus:border-primary-500 focus:ring-1 focus:ring-primary-500"
              />
            </div>
          </div>

          <!-- Hidden fields for data that isn't directly editable -->
          <input type="hidden" id="slug" name="slug" value={slug} />
          <input type="hidden" id="body_html" name="body_html" value={bodyHtml} />
          <input type="hidden" id="raw_html" name="raw_html" value={rawHtml} />
          <input type="hidden" id="references_json" name="references_json" value={JSON.stringify(parsed.references || [])} />
          <input type="hidden" id="acknowledgements" name="acknowledgements" value={parsed.acknowledgements || ""} />
        </form>

        <!-- Editable Abstract Card -->
        <div class="rounded-lg bg-white shadow-sm p-6">
          <h2 class="text-lg font-semibold text-stone-900 border-b border-stone-200 pb-2 mb-4">
            Abstract
            <span id="abstract-chars" class="text-sm font-normal text-stone-500 ml-2">
              ({(parsed.abstract || "").length} chars)
            </span>
          </h2>
          <textarea
            id="abstract"
            name="abstract"
            form="article-form"
            rows="6"
            placeholder="Enter abstract..."
            class="w-full rounded border border-stone-300 px-3 py-2 text-sm leading-relaxed focus:border-primary-500 focus:ring-1 focus:ring-primary-500"
          >{parsed.abstract || ""}</textarea>
        </div>

        <!-- Body HTML Card -->
        <div class="rounded-lg bg-white shadow-sm p-6">
          <h2 class="text-lg font-semibold text-stone-900 border-b border-stone-200 pb-2 mb-4">
            Body Content
            <span class="text-sm font-normal text-stone-500 ml-2">
              ({Math.round(bodyLength / 1024)} KB)
            </span>
          </h2>
          <div
            class="prose prose-stone prose-sm max-w-none article-body"
            set:html={bodyHtml}
          />
        </div>

        <!-- Stripped Cruft -->
        {cruftCount > 0 && (
          <div class="rounded-lg bg-stone-50 border border-stone-200 p-6">
            <h2 class="text-lg font-semibold text-stone-900 border-b border-stone-200 pb-2 mb-4">
              Stripped Content
              <span class="text-sm font-normal text-stone-500 ml-2">
                ({cruftCount} items)
              </span>
            </h2>
            <ul class="space-y-2 text-sm">
              {parsed.stripped_cruft.map((item) => (
                <li class={`font-mono text-xs p-2 rounded ${
                  item.startsWith("[JOINED]")
                    ? "bg-green-50 text-green-800"
                    : "bg-amber-50 text-amber-800"
                }`}>
                  {item}
                </li>
              ))}
            </ul>
          </div>
        )}

        <!-- References -->
        {refCount > 0 && (
          <div class="rounded-lg bg-white shadow-sm p-6">
            <h2 class="text-lg font-semibold text-stone-900 border-b border-stone-200 pb-2 mb-4">
              References
              <span class="text-sm font-normal text-stone-500 ml-2">
                ({refCount})
              </span>
            </h2>
            <ol class="list-decimal list-inside space-y-1 text-sm text-stone-700">
              {parsed.references.map((ref) => (
                <li class="leading-relaxed">{ref}</li>
              ))}
            </ol>
          </div>
        )}

        <!-- Acknowledgements -->
        {parsed.acknowledgements && (
          <div class="rounded-lg bg-white shadow-sm p-6">
            <h2 class="text-lg font-semibold text-stone-900 border-b border-stone-200 pb-2 mb-4">
              Acknowledgements
            </h2>
            <p class="text-sm text-stone-700">{parsed.acknowledgements}</p>
          </div>
        )}
      </>
    ) : (
      <div class="rounded-lg bg-amber-50 border border-amber-200 p-4">
        <h2 class="text-sm font-medium text-amber-800">Not Yet Parsed</h2>
        <p class="mt-1 text-sm text-amber-700">
          Refresh the page to run the parser on this file.
        </p>
      </div>
    )}
  </div>
</AdminLayout>

<style>
  /* Article body styling - plain CSS for Tailwind v4 compatibility */
  .article-body :global(h1) {
    font-size: 1.25rem;
    font-weight: 700;
    margin-top: 2rem;
    margin-bottom: 1rem;
    color: #1c1917;
  }
  .article-body :global(h2) {
    font-size: 1.125rem;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    color: #292524;
  }
  .article-body :global(h3) {
    font-size: 1rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #292524;
  }
  .article-body :global(p) {
    margin-bottom: 1rem;
    line-height: 1.625;
  }
  .article-body :global(table) {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
    font-size: 0.75rem;
  }
  .article-body :global(th),
  .article-body :global(td) {
    border: 1px solid #d6d3d1;
    padding: 0.25rem 0.5rem;
  }
  .article-body :global(th) {
    background-color: #f5f5f4;
    font-weight: 500;
  }
  .article-body :global(img) {
    max-width: 100%;
    height: auto;
    margin: 1rem 0;
    border-radius: 0.25rem;
  }
  .article-body :global(.img-description) {
    font-size: 0.75rem;
    color: #78716c;
    font-style: italic;
    margin-top: 0.25rem;
    margin-bottom: 1rem;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Form submission handler
    const form = document.getElementById('article-form') as HTMLFormElement;
    const statusEl = document.getElementById('form-status');
    const resetBtn = document.getElementById('reset-btn');
    const abstractTextarea = document.getElementById('abstract') as HTMLTextAreaElement;
    const abstractChars = document.getElementById('abstract-chars');

    if (!form) {
      console.error('Form not found');
      return;
    }

    // Store initial values for reset
    const initialValues: Record<string, string> = {};
    const inputs = form.querySelectorAll('input, textarea');
    inputs.forEach((input) => {
      const el = input as HTMLInputElement | HTMLTextAreaElement;
      initialValues[el.id] = el.value;
    });

    // Update abstract character count
    if (abstractTextarea && abstractChars) {
      abstractTextarea.addEventListener('input', () => {
        abstractChars.textContent = `(${abstractTextarea.value.length} chars)`;
      });
    }

    // Reset button
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        Object.keys(initialValues).forEach((id) => {
          const el = document.getElementById(id) as HTMLInputElement | HTMLTextAreaElement;
          if (el) el.value = initialValues[id];
        });
        if (abstractChars) {
          abstractChars.textContent = `(${initialValues['abstract']?.length || 0} chars)`;
        }
        showStatus('Fields reset to original values', 'info');
      });
    }

    // Form submission
    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
      const originalText = submitBtn.textContent;
      submitBtn.textContent = 'Saving...';
      submitBtn.disabled = true;

      try {
        const formData = new FormData(form);
        const data = {
          slug: formData.get('slug'),
          title: formData.get('title'),
          authors: formData.get('authors'),
          year: formData.get('year'),
          citation: formData.get('citation'),
          abstract: formData.get('abstract'),
          body_html: formData.get('body_html'),
          references_json: JSON.parse(formData.get('references_json') as string || '[]'),
          acknowledgements: formData.get('acknowledgements'),
          raw_html: formData.get('raw_html'),
          method: formData.get('method'),
          voice: formData.get('voice'),
          peer_reviewed: formData.get('peer_reviewed') === 'on',
        };

        const response = await fetch('/api/save-parsed-article', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });

        const result = await response.json();

        if (response.ok) {
          showStatus(`Article ${result.action} successfully! ID: ${result.articleId}`, 'success');
        } else {
          showStatus(`Error: ${result.error}`, 'error');
        }
      } catch (err) {
        showStatus(`Network error: ${err}`, 'error');
      } finally {
        submitBtn.textContent = originalText;
        submitBtn.disabled = false;
      }
    });

    function showStatus(message: string, type: 'success' | 'error' | 'info') {
      if (!statusEl) return;
      statusEl.textContent = message;
      statusEl.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-blue-100', 'text-blue-800');

      if (type === 'success') {
        statusEl.classList.add('bg-green-100', 'text-green-800');
      } else if (type === 'error') {
        statusEl.classList.add('bg-red-100', 'text-red-800');
      } else {
        statusEl.classList.add('bg-blue-100', 'text-blue-800');
      }

      // Auto-hide after 5 seconds for success/info
      if (type !== 'error') {
        setTimeout(() => {
          statusEl.classList.add('hidden');
        }, 5000);
      }
    }
  });
</script>
